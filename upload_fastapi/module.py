import time
import tensorflow as tf
from tensorflow import keras,image
from keras.layers import Dense, Dropout
from keras.preprocessing.image import ImageDataGenerator
from keras.layers import Dense, BatchNormalization
import numpy as np
# import matplotlib.pyplot as plt

#CNN模型
def cnn(train_path, test_path, Epochs, SAFE=True):

    train= ImageDataGenerator(rescale=1/255) 
    train_data = train.flow_from_directory(train_path,target_size=(64,64),batch_size = 8,class_mode = 'binary')
    
    test= ImageDataGenerator(rescale=1/255) 
    test_data = test.flow_from_directory(test_path,target_size=(64,64),batch_size = 8,class_mode = 'binary')

    model = keras.Sequential()

    model.add(keras.layers.Conv2D(32,(3,3), padding='same',activation='relu',input_shape=(64,64,3)))
    model.add(keras.layers.Conv2D(16,(3,3),activation='relu'))
    model.add(BatchNormalization())
    model.add(keras.layers.MaxPool2D(2,2))
    model.add(Dropout(0.5))

    model.add(keras.layers.Conv2D(32,(3,3),activation='relu'))
    model.add(keras.layers.MaxPool2D(2,2))
    model.add(BatchNormalization())
    model.add(Dropout(0.5))

    model.add(Dense(units = 32)) #units是輸出空間的維度
    model.add(Dropout(0.5))

    model.add(Dense(units = 32,activation = 'sigmoid'))
    model.add(Dropout(0.5))

    # 把結果攤平到一維array
    model.add(keras.layers.Flatten())

    #用sigmoid activation function 讓模型的output介在0跟1
    model.add(keras.layers.Dense(1,activation='sigmoid'))    

    model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'],steps_per_execution=None)
    start = time.time()
    model.fit(train_data, epochs=Epochs ,batch_size=20,verbose=2, validation_data = test_data)
    stop = time.time()
    print(f"Training time: {(stop - start)/60}min")
    if SAFE==True:
        print("Save model")
        model.save('model.h5') 
    return model



#定義預測的函數
def predictimage(filepath,model,pic=True):

    img1 = tf.keras.utils.load_img(filepath, target_size=(64, 64))
    img = tf.keras.utils.img_to_array(img1)
    img = img/255
    img = np.expand_dims(img, axis=0)
    prediction = model.predict(img, batch_size=None,steps=1) #生成機率
    if(prediction[:,:]>=0.5):
        result ='Malware : %1.2f'%(prediction[0,0])

    else:
        result ='Benign : %1.2f'%(1.0-prediction[0,0])
        
    # if pic ==True:
    #     print("The probability of this data being {}".format(value))
    #     if (prediction[:,:]>=0.5):
    #         plt.text(20, 62,value,color='red',fontsize=18,bbox=dict(facecolor='white',alpha=0.8))
    #     else:
    #         plt.text(20, 62,value,color='blue',fontsize=18,bbox=dict(facecolor='white',alpha=0.8))
    #     plt.imshow(img1)
    #     plt.show()
    # else:
    #     print("The probability of this data being {}".format(value))  
    
    return result


if __name__ == "__main__":
    epochs = 20
    train_path = "./data/train/"
    test_path = "./data/val/"
    cnn(train_path, test_path, epochs, SAFE=True)