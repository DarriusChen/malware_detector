#本函數的目的是將欲判斷的檔案轉成image

import cv2
import os.path
import numpy as np
from PIL import Image
from os import listdir

#圖片的寬會根據檔案大小而有改變
def width(kb):
    if kb<10:
        w=32
    elif 10<kb<30 :
        w=64
    elif 30<kb<60 :
        w=128
    elif 60<kb<100 :
        w=256
    elif 100<kb<200 :
        w=384
    elif 200<kb<500 :
        w=512
    elif 500<kb<1000 :
        w=768
    else:
        w=1024
    return(w)

#本函數會透過雙線性演算法去resize你的圖片大小
#若檔案很大，執行以下檔案會花許多時間，請小心服用
def exe2image(data_path,file):
    #count=1
    #for file in listdir(data_path):
    f=open(os.path.join(data_path, file), 'rb')
    data = f.read()
    d=np.array(list(data))
    size=len(d)
    kb=int(size/1024)
    w=width(kb)
    h=int(size/w)
    d=d[0:w*h] #將array的後面切掉
    d1 = d.reshape(h,w) 
    PILimage = Image.fromarray(np.uint8(d1))
    #PILimage.save('B_%d.png'%count) #如果想要看檔案轉image長什麼樣子（未resize過），執行此行可以存圖片
    #count += 1
    #img = cv2.imread(os.path.join(benign_path, i), cv2.IMREAD_COLOR)
    #可自行更改您想要的圖片長寬
    dst = cv2.resize(np.asarray(PILimage), (64, 64), cv2.INTER_LINEAR) #cv2.inter_linear為雙線性演算法的套件
    #cv2.imwrite('./M_%d.jpg'%count2, dst) #可自行更改檔名
    return dst
"""
def image_resize(img):
    #count=1
    for i in listdir(malware_path):
        img = cv2.imread(os.path.join(malware_path, i), cv2.IMREAD_COLOR)
        dst = cv2.resize(img, (h, w), cv2.INTER_LINEAR)
        cv2.imwrite('./M_%d.jpg'%count, dst) #可自行更改檔名
        count += 1
"""
def run(data_path, out_path):
    for file in listdir(data_path):
       img = exe2image(data_path,file)
       cv2.imwrite('./%s/%s.jpg'%(out_path, file), img) #可自行更改檔名

if __name__ == "__main__":

    #請輸入執行檔的位置    
    data_path="./exe file/Malicious"
    #請輸入你儲存的圖片路徑
    #benign_path = './image/B/'
    malware_path = './image/M/'

    #run(data_path, benign_path)
    run(data_path, malware_path)
